name: CI

on:
  push:
    branches: [ main, 'claude/**' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SWIFT_VERSION: '6.0'

jobs:
  # Linux stage - runs first
  linux:
    name: Linux Build & Test
    runs-on: ubuntu-latest
    container:
      image: swift:6.0

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build tools
        run: apt-get update && apt-get install -y make pkg-config wget unzip

      - name: Build SQLite with SQLITE_ENABLE_SNAPSHOT
        run: |
          cd /tmp
          wget -q https://www.sqlite.org/2024/sqlite-autoconf-3470200.tar.gz
          tar xzf sqlite-autoconf-3470200.tar.gz
          cd sqlite-autoconf-3470200
          CFLAGS="-DSQLITE_ENABLE_SNAPSHOT=1 -O2" ./configure --prefix=/usr/local
          make -j$(nproc)
          make install
          ldconfig
          # Verify installation
          echo "=== SQLite Installation Verification ==="
          ls -l /usr/local/lib/libsqlite3.so*
          sqlite3 --version
          echo "Checking for snapshot support..."
          sqlite3 :memory: "PRAGMA compile_options;" | grep -i snapshot || echo "Warning: SNAPSHOT not found in compile options"
          # Verify pkg-config can find our custom SQLite
          export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH}
          echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH}"
          echo "pkg-config --modversion sqlite3:"
          pkg-config --modversion sqlite3 || echo "ERROR: pkg-config cannot find sqlite3"
          echo "pkg-config --cflags sqlite3:"
          pkg-config --cflags sqlite3 || true
          echo "pkg-config --libs sqlite3:"
          pkg-config --libs sqlite3 || true
          # Verify the library has the required symbols
          echo "=== Symbol Verification ==="
          nm -D /usr/local/lib/libsqlite3.so | grep -E 'sqlite3_sql|sqlite3_snapshot_open' || echo "Warning: symbols not found"

      - name: Display Swift version
        run: swift --version

      - name: Run preflight checks
        run: |
          chmod +x scripts/preflight.sh
          make preflight
        continue-on-error: false
        env:
          PKG_CONFIG_PATH: /usr/local/lib/pkgconfig
          LIBRARY_PATH: /usr/local/lib
          LD_LIBRARY_PATH: /usr/local/lib
          CPATH: /usr/local/include

      - name: Build Swift packages
        run: swift build -v
        continue-on-error: false
        env:
          PKG_CONFIG_PATH: /usr/local/lib/pkgconfig
          LIBRARY_PATH: /usr/local/lib
          LD_LIBRARY_PATH: /usr/local/lib
          CPATH: /usr/local/include

      - name: Run tests (parallel)
        id: test
        shell: bash
        run: |
          swift test --parallel 2>&1 | tee /tmp/test-output.log
          exit ${PIPESTATUS[0]}
        continue-on-error: false
        env:
          PKG_CONFIG_PATH: /usr/local/lib/pkgconfig
          LIBRARY_PATH: /usr/local/lib
          LD_LIBRARY_PATH: /usr/local/lib
          CPATH: /usr/local/include

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-test-logs
          path: |
            /tmp/test-output.log
            /tmp/preflight_build.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload test fixtures (JSON)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: linux-test-fixtures
          path: |
            Tests/Fixtures/**/*.json
            /tmp/*.json
          retention-days: 7
          if-no-files-found: ignore

      - name: Failure summary
        if: failure()
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✗ Linux CI failed - check logs above for details"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          exit 1

  # macOS stage - runs after Linux succeeds
  macos:
    name: macOS Build (no XCTest targets yet)
    runs-on: macos-14
    needs: linux

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Select Xcode version
        run: |
          sudo xcode-select -s /Applications/Xcode_16.1.app/Contents/Developer || \
          sudo xcode-select -s /Applications/Xcode_16.app/Contents/Developer || \
          echo "Warning: Could not find Xcode 16.1+, using default"
          xcodebuild -version

      - name: Display Swift version
        run: swift --version

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Generate Xcode project
        run: |
          echo "━━━ Generating Xcode project from project.yml ━━━"
          xcodegen generate --spec project.yml
          echo ""
          echo "━━━ Generated project structure ━━━"
          ls -la HomeCooked.xcodeproj/
          echo ""
          echo "━━━ Checking if scheme exists ━━━"
          ls -la HomeCooked.xcodeproj/xcshareddata/xcschemes/ || echo "No shared schemes found"

      - name: Validate Xcode project
        run: |
          echo "━━━ Listing available schemes ━━━"
          xcodebuild -list -project HomeCooked.xcodeproj
          echo ""
          echo "━━━ Showing build settings for HomeCooked scheme ━━━"
          xcodebuild -project HomeCooked.xcodeproj \
            -scheme HomeCooked \
            -showBuildSettings | head -50

      - name: Select iOS Simulator
        id: select-simulator
        run: |
          echo "━━━ Finding available iOS Simulators ━━━"

          # List all available iPhone simulators
          xcrun simctl list devices available iPhone -j > /tmp/simulators.json

          # Try to find iPhone 15 with highest available iOS version
          SIMULATOR_ID=$(cat /tmp/simulators.json | jq -r '
            .devices
            | to_entries[]
            | select(.key | startswith("com.apple.CoreSimulator.SimRuntime.iOS"))
            | .value[]
            | select(.name | startswith("iPhone 15") and (. | endswith("Plus") | not) and (. | endswith("Pro") | not))
            | select(.isAvailable == true)
            | .udid' | head -1)

          # If iPhone 15 not found, fall back to any available iPhone
          if [ -z "$SIMULATOR_ID" ]; then
            echo "iPhone 15 not found, selecting first available iPhone..."
            SIMULATOR_ID=$(cat /tmp/simulators.json | jq -r '
              .devices
              | to_entries[]
              | select(.key | startswith("com.apple.CoreSimulator.SimRuntime.iOS"))
              | .value[]
              | select(.name | startswith("iPhone"))
              | select(.isAvailable == true)
              | .udid' | head -1)
          fi

          # Get simulator details
          SIMULATOR_NAME=$(cat /tmp/simulators.json | jq -r ".devices | to_entries[] | .value[] | select(.udid == \"$SIMULATOR_ID\") | .name")
          SIMULATOR_OS=$(cat /tmp/simulators.json | jq -r ".devices | to_entries[] | select(.value[] | .udid == \"$SIMULATOR_ID\") | .key" | sed 's/com.apple.CoreSimulator.SimRuntime.iOS-//' | sed 's/-/./g')

          echo "Selected Simulator:"
          echo "  Name: $SIMULATOR_NAME"
          echo "  OS: iOS $SIMULATOR_OS"
          echo "  UDID: $SIMULATOR_ID"

          # Export for use in subsequent steps
          echo "SIMULATOR_ID=$SIMULATOR_ID" >> $GITHUB_OUTPUT
          echo "SIMULATOR_NAME=$SIMULATOR_NAME" >> $GITHUB_OUTPUT
          echo "SIMULATOR_OS=$SIMULATOR_OS" >> $GITHUB_OUTPUT

      - name: Cache DerivedData
        uses: actions/cache@v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-deriveddata-${{ hashFiles('Package.swift', 'App/**/*.swift') }}
          restore-keys: |
            ${{ runner.os }}-deriveddata-

      - name: Cache SwiftPM packages
        uses: actions/cache@v4
        with:
          path: .build
          key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Run preflight checks
        run: |
          chmod +x scripts/preflight.sh
          make preflight
        continue-on-error: false

      - name: Install xcpretty (optional)
        run: |
          if ! command -v xcpretty &> /dev/null; then
            echo "Installing xcpretty for better output formatting..."
            gem install xcpretty || echo "Failed to install xcpretty, continuing without it"
          fi

      - name: Build iOS app
        id: build
        run: |
          set -o pipefail
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Starting iOS app build"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Destination: id=${{ steps.select-simulator.outputs.SIMULATOR_ID }}"
          echo "Device: ${{ steps.select-simulator.outputs.SIMULATOR_NAME }} (iOS ${{ steps.select-simulator.outputs.SIMULATOR_OS }})"
          echo "Scheme: HomeCooked"
          echo "DerivedData: ~/Library/Developer/Xcode/DerivedData/HomeCooked"
          echo ""

          # Build without xcpretty to see full verbose output
          echo "━━━ Running xcodebuild build (full verbose output) ━━━"
          xcodebuild -project HomeCooked.xcodeproj \
            -scheme HomeCooked \
            -destination "id=${{ steps.select-simulator.outputs.SIMULATOR_ID }}" \
            -derivedDataPath ~/Library/Developer/Xcode/DerivedData/HomeCooked \
            build 2>&1 | tee /tmp/xcodebuild-build.log

          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          echo ""
          echo "━━━ Build command completed with exit code: $BUILD_EXIT_CODE ━━━"

          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "━━━ BUILD FAILED - Showing last 100 lines ━━━"
            tail -100 /tmp/xcodebuild-build.log
          fi

          exit $BUILD_EXIT_CODE
        continue-on-error: false

      - name: Verify build success
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✓ iOS app build completed successfully"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Note: All unit/integration tests run on Linux via SwiftPM."
          echo "The macOS job only verifies the iOS app builds correctly."
          echo "XCTest UI tests will be added in a future ticket."

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macos-build-logs
          path: |
            /tmp/xcodebuild-build.log
            /tmp/preflight*.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Display build failure details
        if: failure()
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "BUILD FAILURE DETECTED - Displaying diagnostics"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""

          if [ -f /tmp/xcodebuild-build.log ]; then
            echo "━━━ Last 200 lines of BUILD log ━━━"
            tail -200 /tmp/xcodebuild-build.log
            echo ""
          fi

          echo "━━━ Checking for common build issues ━━━"
          echo ""
          echo "Scheme issues:"
          grep -i "scheme.*not found\|could not find scheme" /tmp/xcodebuild-build.log 2>/dev/null || echo "No scheme errors found"
          echo ""
          echo "Package resolution issues:"
          grep -i "package.*error\|dependencies could not be resolved" /tmp/xcodebuild-build.log 2>/dev/null || echo "No package errors found"
          echo ""
          echo "Code signing issues:"
          grep -i "signing\|provisioning" /tmp/xcodebuild-build.log 2>/dev/null || echo "No signing errors found"
          echo ""
          echo "App Intents / SSU issues:"
          grep -i "appintentsnltrainingprocessor\|ssutraining\|utskit.*error\|archive ssu" /tmp/xcodebuild-build.log 2>/dev/null || echo "No App Intents/SSU errors found"
          echo ""
          echo "Swift compilation errors:"
          grep -i "error:.*swift\|cannot find.*in scope" /tmp/xcodebuild-build.log 2>/dev/null | head -20 || echo "No Swift compilation errors found"

      - name: Failure summary
        if: failure()
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✗ macOS build failed - check logs above for details"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          exit 1
